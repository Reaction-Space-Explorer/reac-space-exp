
// Match the 3 major structures. *1..6 limits the size of the ring to a maximum of 6 molecules, so increase this if needed (will take longer time to query)
MATCH ringPath=(beginMol:Molecule)-[:FORMS*1..6]->(beginMol:Molecule),
branchedBeginMolPath=(beginMol:Molecule)-[:FORMS]->(beginMolConsumer:Molecule),
attachedPath=(feederMol:Molecule)-[:FORMS]->(intermediateMol:Molecule)-[:FORMS]->(consumerMol:Molecule)


// Create the iterator ringMol to iterate over all the molecules in the ringPath, assuring that only the distinct smiles strings are counted in ringMols (otherwise results will duplicate the beginMol because the ring query starts and ends at beginMol)
UNWIND nodes(ringPath) as ringMol
WITH collect(distinct ringMol.smiles_str) AS ringMols, ringPath, relationships(ringPath) as ringRels, beginMol, beginMolConsumer, branchedBeginMolPath, attachedPath, feederMol, intermediateMol, consumerMol

// Filter the query by several conditions
WHERE size(ringMols) > 2 // controls number of molecules in the ring
AND size(ringRels) = size(ringMols) // asserts that the number of molecules must equal the number of relationships in the ring (so the relationships don't hop molecules more than once and create a collapsed ring figure 8 looking structure
AND beginMol <> beginMolConsumer
AND NOT beginMolConsumer.smiles_str IN ringMols
AND beginMolConsumer <> feederMol
AND beginMol <> feederMol
AND feederMol <> consumerMol
AND beginMol <> consumerMol
AND NOT feederMol.smiles_str IN ringMols
AND NOT consumerMol.smiles_str IN ringMols
AND beginMolConsumer <> consumerMol
//AND NOT (beginMol:Molecule)-[:FORMS]->(beginMol:Molecule)<-[:FORMS]-(beginMol:Molecule) // Assert that the relationships in the ringPath must travel all in the same direction
//AND feederMol.generation_formed = 3 // control the generation at which the cycle is formed by assuming it can't exist until after the feederMol is formed

// Finally, return 1 matching structure to look at! (Tabulate results of many using a different query)
RETURN ringMols, size(ringMols) as countMolsInRing, ringPath, ringRels, beginMol, beginMolConsumer, branchedBeginMolPath, attachedPath, feederMol, intermediateMol, consumerMol
LIMIT 1